export interface IconOptions {
  size?: number | string
  color?: string
  strokeWidth?: number | string
  className?: string
  title?: string
  ariaLabel?: string
  ariaHidden?: boolean
  [key: string]: any
}

export type IconNode = [string, Record<string, any>, IconNode[]?]

export function createIcon(name: string, iconNode: IconNode[], keepColors = false) {
  return (options: IconOptions = {}): SVGSVGElement => {
    const {
      size = 24,
      color = 'currentColor',
      strokeWidth = 2,
      className = '',
      title,
      ariaLabel,
      ariaHidden,
      ...attrs
    } = options

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    svg.setAttribute('width', String(size))
    svg.setAttribute('height', String(size))
    svg.setAttribute('viewBox', '0 0 24 24')
    svg.setAttribute('class', className ? `vectify-icon ${className}` : 'vectify-icon')

    // Accessibility
    const shouldHide = ariaHidden !== undefined ? ariaHidden : (!title && !ariaLabel)
    if (shouldHide) {
      svg.setAttribute('aria-hidden', 'true')
    }
    if (ariaLabel) {
      svg.setAttribute('aria-label', ariaLabel)
    }
    if (title || ariaLabel) {
      svg.setAttribute('role', 'img')
    }

    // Set additional attributes
    Object.entries(attrs).forEach(([key, value]) => {
      svg.setAttribute(key, String(value))
    })

    // Add title if provided
    if (title) {
      const titleEl = document.createElementNS('http://www.w3.org/2000/svg', 'title')
      titleEl.textContent = title
      svg.appendChild(titleEl)
    }

    // Render icon nodes
    function renderNode(node: IconNode): SVGElement {
      const [type, nodeAttrs, children] = node
      const element = document.createElementNS('http://www.w3.org/2000/svg', type)

      let cleanedAttrs: Record<string, any>

      if (keepColors) {
        cleanedAttrs = nodeAttrs
      } else {
        // Track color attributes
        let hasFill = false
        let hasStroke = false
        let originalStrokeWidth: number | string | undefined

        Object.entries(nodeAttrs).forEach(([key, value]) => {
          if (key === 'fill' && value !== 'none') {
            hasFill = true
          }
          if (key === 'stroke') {
            hasStroke = true
          }
          if (key === 'strokeWidth' || key === 'stroke-width') {
            originalStrokeWidth = value
          }
        })

        // Keep non-color attributes
        cleanedAttrs = Object.fromEntries(
          Object.entries(nodeAttrs).filter(([key]) =>
            !['stroke', 'fill', 'strokeWidth', 'stroke-width'].includes(key)
          )
        )

        // Apply color
        if (hasFill) {
          cleanedAttrs.fill = color
        } else if (hasStroke) {
          cleanedAttrs.fill = 'none'
          cleanedAttrs.stroke = color
          cleanedAttrs['stroke-width'] = originalStrokeWidth ?? strokeWidth
          cleanedAttrs['stroke-linecap'] = 'round'
          cleanedAttrs['stroke-linejoin'] = 'round'
        }
      }

      // Set attributes
      Object.entries(cleanedAttrs).forEach(([key, value]) => {
        element.setAttribute(key, String(value))
      })

      // Render children
      if (children && children.length > 0) {
        children.forEach(child => {
          element.appendChild(renderNode(child))
        })
      }

      return element
    }

    iconNode.forEach(node => {
      svg.appendChild(renderNode(node))
    })

    return svg
  }
}
