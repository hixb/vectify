import { JSX, splitProps } from 'solid-js'
import type { IconNode } from 'vectify'

export interface CreateIconProps {
  size?: number | string
  color?: string
  strokeWidth?: number | string
  class?: string
  title?: string
  'aria-label'?: string
  'aria-hidden'?: boolean | 'true' | 'false'
  [key: string]: any
}

export function createIcon(name: string, iconNode: IconNode[], keepColors = false) {
  return (props: CreateIconProps): JSX.Element => {
    const [local, others] = splitProps(props, [
      'size',
      'color',
      'strokeWidth',
      'class',
      'title',
      'aria-label',
      'aria-hidden'
    ])

    const size = () => local.size ?? 24
    const color = () => local.color ?? 'currentColor'
    const strokeWidth = () => local.strokeWidth ?? 2

    // Determine if icon should be hidden from screen readers
    const shouldHide = () => local['aria-hidden'] !== undefined 
      ? local['aria-hidden'] 
      : (!local.title && !local['aria-label'])

    const mergedClass = () => local.class ? `vectify-icon ${local.class}` : 'vectify-icon'

    const renderIconNode = (nodes: IconNode[]): JSX.Element[] => {
      return nodes.map((node, index) => {
        const [type, attrs, children] = node

        let cleanedAttrs: Record<string, any>

        if (keepColors) {
          cleanedAttrs = attrs
        } else {
          // Track color attributes to determine icon type
          let hasFill = false
          let hasStroke = false
          let originalStrokeWidth: number | string | undefined

          Object.entries(attrs).forEach(([key, value]) => {
            if (key === 'fill' && value !== 'none') {
              hasFill = true
            }
            if (key === 'stroke') {
              hasStroke = true
            }
            if (key === 'strokeWidth' || key === 'stroke-width') {
              originalStrokeWidth = value
            }
          })

          // Keep non-color attributes
          cleanedAttrs = Object.fromEntries(
            Object.entries(attrs).filter(([key]) =>
              !['stroke', 'fill', 'strokeWidth', 'stroke-width'].includes(key)
            )
          )

          // Apply color based on original attributes
          if (hasFill) {
            cleanedAttrs.fill = color()
          } else if (hasStroke) {
            cleanedAttrs.fill = 'none'
            cleanedAttrs.stroke = color()
            cleanedAttrs.strokeWidth = originalStrokeWidth ?? strokeWidth()
            cleanedAttrs.strokeLinecap = 'round'
            cleanedAttrs.strokeLinejoin = 'round'
          }
        }

        const props = { ...cleanedAttrs }

        if (children && children.length > 0) {
          return (
            <Dynamic component={type} {...props}>
              {renderIconNode(children)}
            </Dynamic>
          )
        }

        return <Dynamic component={type} {...props} />
      })
    }

    return (
      <svg
        width={size()}
        height={size()}
        viewBox="0 0 24 24"
        aria-hidden={shouldHide()}
        aria-label={local['aria-label']}
        role={local.title || local['aria-label'] ? 'img' : undefined}
        {...others}
        class={mergedClass()}
      >
        {local.title && <title>{local.title}</title>}
        {renderIconNode(iconNode)}
      </svg>
    )
  }
}

// Dynamic component helper
function Dynamic(props: { component: string; children?: any; [key: string]: any }) {
  const [local, others] = splitProps(props, ['component', 'children'])
  
  // Create element using the component name
  const El = local.component as any
  
  return <El {...others}>{local.children}</El>
}
